require("dotenv").config();
const { ethers } = require('ethers');
const MoneroRPC = require('./monero-rpc');
const EnhancedTSSManager = require('./tss');
const { SecureSigningSystem, RefreshCoordinator } = require('./secure-signing-system');

const CLUSTER_SIZE = 11;
const REQUIRED_SIGNERS = 8;

class ZNode {
  constructor() {
    this.provider = new ethers.JsonRpcProvider(
      process.env.RPC_URL || 'https://eth-sepolia.g.alchemy.com/v2/vO5dWTSB5yRyoMsJTnS6V'
    );
    
    this.wallet = new ethers.Wallet(process.env.PRIVATE_KEY, this.provider);
    
    // Contract ABIs
    const registryABI = [
      'function selectNextNode() external',
      'function registerNode(bytes32 codeHash, string moneroPublicKey) external',
      'function getActiveClusterCount() external view returns (uint256)',
      "function allClusters(uint256) external view returns (bytes32)",
      'function getQueueStatus() external view returns (uint256, uint256, bool)',
      'function getFormingCluster() external view returns (address[], uint256, bool)',
      'function getFormingClusterMultisigInfo() external view returns (address[], string[])',
      'function confirmCluster(string moneroAddress) external',
      'function getClusterInfo(bytes32 clusterId) external view returns (address[11], string, address[], uint256, uint256, bool)',
      'function getShareEpochInfo(bytes32 clusterId, uint256 epoch) external view returns (address[], uint256, uint256, bool)',
      'function submitSharesForEpoch(bytes32 clusterId, uint256 epoch, bytes encryptedShares) external',
      'function getSharesForEpoch(bytes32 clusterId, uint256 epoch, address node) external view returns (bytes)',
      'function proposeRefresh(bytes32 clusterId, address[] newMembers, address[] removedMembers) external',
      'function approveRefresh(bytes32 clusterId, uint256 proposalId) external',
      'function activeProposal(bytes32 clusterId) external view returns (uint256)',
      'function checkAndTriggerRefresh(bytes32 clusterId) external',
      'event RefreshExecuted(bytes32 indexed clusterId, uint256 newEpoch)',
      'event RefreshProposed(bytes32 indexed clusterId, uint256 indexed proposalId, address proposer, address[] newMembers, address[] removedMembers)',
      'event EpochCompleted(bytes32 indexed clusterId, uint256 indexed epoch)'
    ];
    
    const stakingABI = [
      'function getNodeInfo(address) external view returns (uint256, uint256, uint256, bool, uint256, uint256, uint256)',
      'function stake(bytes32 _codeHash, string _moneroFeeAddress) external',
      'function heartbeat() external'
    ];
    
    this.registry = new ethers.Contract(
      "0x0d61108F118595629aDcfB12448B7b0626D753B7",
      registryABI,
      this.wallet
    );
    
    this.staking = new ethers.Contract(
      "0x4725E47790FD8C0354476BbE1e5870091D5a4fb8",
      stakingABI,
      this.wallet
    );
    
    const zfiABI = [
      'function balanceOf(address) external view returns (uint256)',
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)'
    ];
    
    this.zfi = new ethers.Contract(
      "0xDe4D33F70D1Abf076Dee4A722e3440EE596116aE",
      zfiABI,
      this.wallet
    );
    
    this.monero = new MoneroRPC({
      url: process.env.MONERO_RPC_URL || 'http://127.0.0.1:18083'
    });
    
    this.walletName = `znode3_${this.wallet.address.slice(2, 10)}`;
    this.multisigInfo = null;
    this.clusterId = null;
    this.refreshCoordinator = null;
  }

  async start() {
    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('     zNode - Dynamic TSS Edition');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    console.log(`Address: ${this.wallet.address}`);
    console.log(`Network: Sepolia\n`);

    await this.checkRequirements();
    await this.setupMonero();
    await this.registerToQueue();
    await this.monitorNetwork();
  }

  async checkRequirements() {
    console.log('‚Üí Checking requirements...\n');

    const ethBalance = await this.provider.getBalance(this.wallet.address);
    console.log(`  ETH Balance: ${ethers.formatEther(ethBalance)}`);
    
    if (ethBalance < ethers.parseEther('0.001')) {
      throw new Error('Insufficient ETH. Need at least 0.001 ETH for gas.');
    }

    const nodeInfo = await this.staking.getNodeInfo(this.wallet.address);
    const stakedAmount = nodeInfo[0];
    
    console.log(`  Staked ZFI: ${ethers.formatEther(stakedAmount)}`);
    
    if (stakedAmount >= ethers.parseEther('1000000')) {
      console.log('‚úì Requirements met (1000000.0 ZFI already staked)\n');
    } else {
      // Auto-stake logic
      const zfiBalance = await this.zfi.balanceOf(this.wallet.address);
      console.log(`  ZFI Balance: ${ethers.formatEther(zfiBalance)}`);
      
      if (zfiBalance < ethers.parseEther('1000000')) {
        throw new Error('Insufficient ZFI. Need 1M ZFI in wallet to stake.');
      }
      
      console.log('  Approving ZFI for staking...');
      const allowance = await this.zfi.allowance(this.wallet.address, await this.staking.getAddress());
      
      if (allowance < ethers.parseEther('1000000')) {
        const approveTx = await this.zfi.approve(
          await this.staking.getAddress(),
          ethers.parseEther('1000000')
        );
        await approveTx.wait();
        console.log('  ‚úì ZFI approved');
      }
      
      console.log('  Staking 1M ZFI...');
      const codeHash = ethers.id('znode-v2-tss');
      const moneroAddr = '4' + '0'.repeat(94);
      const stakeTx = await this.staking.stake(codeHash, moneroAddr);
      await stakeTx.wait();
      console.log('‚úì Successfully staked 1M ZFI\n');
    }
  }


  async setupMonero() {
    console.log('‚Üí Setting up Monero...');
    
    // Wait for monero RPC to be ready
    for (let i = 1; i <= 20; i++) {
      try {
        await this.monero.openWallet(this.walletName);
        console.log(`‚úì Wallet opened: ${this.walletName}`);
        break;
      } catch (error) {
        if (error.code === 'ECONNREFUSED' && i < 10) {
          console.log(`  Waiting for Monero RPC (attempt ${i}/10)...`);
          await new Promise(r => setTimeout(r, 3000));
          continue;
        }
        
        if (error.code === 'ECONNREFUSED') {
          throw new Error('Monero RPC not available after 60s. Is monero-wallet-rpc running?');
        }
        
        console.log('  Creating wallet...');
        await this.monero.createWallet(this.walletName);
        console.log(`‚úì Wallet created: ${this.walletName}`);
        break;
      }
    }

    console.log('  Preparing multisig...');
    this.multisigInfo = await this.monero.prepareMultisig();
    console.log('‚úì Ready for 8-of-11 multisig\n');
  }

  async registerToQueue() {
    console.log('‚Üí Registering to network...');
    const codeHash = ethers.id('znode-v2-tss');
    
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const tx = await this.registry.registerNode(codeHash, this.multisigInfo);
        console.log('  Transaction sent:', tx.hash);
        const receipt = await tx.wait();
        console.log('  Transaction confirmed in block:', receipt.blockNumber);
        
        // Verify we're actually in the queue
        await new Promise(r => setTimeout(r, 2000)); // Wait 2s for indexing
        const queueSize = await this.registry.getQueueSize();
        console.log('  Current queue size:', queueSize.toString());
        
        console.log('‚úì Registered to cluster queue\n');
        return;
      } catch (error) {
        if (error.message.includes('Already registered')) {
          console.log('‚úì Already registered\n');
          return;
        }
        
        console.log(`  Registration attempt ${attempt}/3 failed:`, error.message);
        if (attempt < 3) {
          console.log(`  Retrying in ${attempt * 2}s...`);
          await new Promise(r => setTimeout(r, attempt * 2000));
        } else {
          throw error;
        }
      }
    }
  }

  async checkExistingCluster() {
    // Check ALL clusters and find the LATEST one we're in (complete or incomplete)
    const clusterCount = await this.registry.getActiveClusterCount();
    let latestCluster = null;
    let latestIndex = -1;
    
    console.log('\n  Checking', clusterCount.toString(), 'clusters for membership...');
    
    for (let i = 0; i < clusterCount; i++) {
      try {
        const clusterId = await this.registry.allClusters(i);
        const clusterInfo = await this.registry.getClusterInfo(clusterId);
        
        if (clusterInfo[0].includes(this.wallet.address)) {
          // Check if epoch has shares (indicates cluster completed TSS)
          try {
            const epochInfo = await this.registry.getShareEpochInfo(clusterId, 0);
            const isComplete = epochInfo[3];
            console.log('  ‚úì Found in cluster', i, isComplete ? '(complete)' : '(incomplete)');
            latestCluster = clusterId;
            latestIndex = i;
          } catch (e) {
            console.log('  ‚úì Found in cluster', i, '(epoch info unavailable)');
          latestCluster = clusterId;
          latestIndex = i;
          }
        }
      } catch (e) {
        // Skip if cluster read fails
      }
    }
    
    if (latestCluster) {
      console.log('\n‚úì Using latest complete cluster', latestIndex);
      this.clusterId = latestCluster;
      console.log('  Cluster ID:', this.clusterId.slice(0, 18) + '...');
      return true;
    }
    
    return false;
  }


  async monitorNetwork() {
    // First check if already in a cluster
    const inCluster = await this.checkExistingCluster();
    if (inCluster) {
      // Check if epoch is active (TSS completed)
      try {
        const epochInfo = await this.registry.getShareEpochInfo(this.clusterId, 0);
        const epochActive = epochInfo[3];
        
        if (epochActive) {
          console.log('\n‚Üí Cluster fully operational\n');
          // TODO: Add cluster maintenance/monitoring here
          return;
        } else {
          console.log('\n‚ö†Ô∏è  Incomplete cluster detected (TSS not finalized)');
          console.log('   Resuming share distribution for this cluster...');
          await this.resumeShareDistribution();
          return;
        }
      } catch (e) {
        console.log('\n‚úì Cluster operational (legacy mode)\n');
        return;
      }
    }
    
    console.log('‚Üí Monitoring network...\n');
    console.log('Node is active and monitoring for cluster formation.');
    console.log("Nodes selected continuously until cluster forms.\n");

    // Send heartbeat every 30 minutes
    setInterval(async () => {
      try {
        await this.staking.heartbeat();
      } catch (error) {
        console.error("Heartbeat failed:", error.message);
      }
    }, 30 * 60 * 1000);

    setInterval(async () => {
      try {
        await this.checkClusterStatus();
      } catch (error) {
        console.error('Monitor error:', error.message);
      }
    }, 60000); // Every minute
  }

  async checkClusterStatus() {
    // Get queue and cluster status
    const [queueLength, , canRegister] = await this.registry.getQueueStatus();
    const [selectedNodes, lastSelectionTime, completed] = await this.registry.getFormingCluster();
    const clusterCount = await this.registry.getActiveClusterCount();
    const selectedCount = selectedNodes.length;
    
    // Calculate time until next selection
    const now = Math.floor(Date.now() / 1000);
    const timeSinceLastSelection = now - Number(lastSelectionTime);
    const timeUntilNext = 0;
    const hoursRemaining = Math.floor(timeUntilNext / 3600);
    
    // Log status update
    const totalNodes = Number(queueLength) + selectedCount;
    console.log(`\\rGood: ${queueLength}/${totalNodes} | Selected: ${selectedCount}/11 | Clusters: ${clusterCount} | Next: ${hoursRemaining > 0 ? hoursRemaining + "h" : "Ready"}`)
    
    // Auto-trigger selection if ready and cluster not full
    // First cluster (no existing clusters): no time check needed
    // No interval - continuous selection
    const canTrigger = selectedCount < 11 && (Number(queueLength) + selectedCount) >= 11;
    const isFirstCluster = selectedCount === 0; // First cluster being formed
    const intervalMet = true; // Always allow selection
    
    if (canTrigger && intervalMet) {
      try {
        console.log('\n‚Üí Triggering node selection...');
        const tx = await this.registry.selectNextNode();
        await tx.wait();
        console.log(`‚úì Node selected (${selectedCount + 1}/11)\n`);
      } catch (e) {
        // Ignore if another node already triggered it
        if (!e.message.includes("ARRAY_RANGE_ERROR") && !e.message.includes("Selection interval not met")) {
          console.log('  Selection trigger failed:', e.message.split('\n')[0]);
        }
      }
    };

    if (completed && !this.clusterId) {
      const isSelected = selectedNodes.some(
        addr => addr.toLowerCase() === this.wallet.address.toLowerCase()
      );

      if (isSelected && selectedCount === CLUSTER_SIZE) {
        console.log('\nüéâ Selected for cluster! Finalizing with TSS...\n');
        await this.finalizeClusterWithTSS();
      }
    }
  }

  async finalizeClusterWithTSS() {
    console.log('‚Üí Finalizing cluster with Dynamic TSS...');
    
    try {
      // Step 1: Fetch all selected nodes' multisig info
      console.log('  Fetching multisig info from all nodes...');
      const [addresses, multisigInfos] = await this.registry.getFormingClusterMultisigInfo();
      
      console.log(`  Got multisig info from ${addresses.length} nodes`);
      
      // Step 2: Collect other nodes' info
      const otherMultisigInfos = [];
      for (let i = 0; i < addresses.length; i++) {
        if (addresses[i].toLowerCase() !== this.wallet.address.toLowerCase()) {
          otherMultisigInfos.push(multisigInfos[i]);
        }
      }
      
      // Step 3: Create multisig wallet
      console.log('  Creating 8-of-11 multisig wallet...');
      const makeResult = await this.monero.makeMultisig(otherMultisigInfos, REQUIRED_SIGNERS);
      const multisigAddress = makeResult.address;
      
      console.log(`‚úì Multisig wallet: ${multisigAddress.slice(0, 12)}...`);
      
      // Step 4: Extract private key for TSS
      console.log('\n  üîê Extracting private key for TSS...');
      const privateSpendKey = await this.monero.queryKey('spend_key');
      
      // Step 5: Confirm cluster on-chain
      console.log('  Confirming cluster...');
      
      try {
        const tx = await this.registry.confirmCluster(multisigAddress);
        await tx.wait();
        console.log('‚úì Cluster confirmed!');
      } catch (error) {
        if (error.message.includes('revert')) {
          console.log('‚úì Cluster already confirmed by another node');
        } else {
          throw error;
        }
      }
      
      // Step 6: Calculate cluster ID (DON'T SORT - contract uses selection order!)
      console.log('  DEBUG: Calculating cluster ID from', addresses.length, 'addresses');
      console.log('  DEBUG: First 3:', addresses.slice(0, 3));
      this.clusterId = ethers.keccak256(
        ethers.solidityPacked(['address[11]'], [addresses])
      );
      console.log('  DEBUG: Calculated cluster ID:', this.clusterId);
      
      console.log(`  Cluster ID: ${this.clusterId.slice(0, 18)}...`);
      
      // Step 7: Initialize TSS and distribute shares (Epoch 0)
      console.log('\n  üì§ Distributing initial shares (Epoch 0)...');
      const tss = new EnhancedTSSManager(
        this.wallet,
        this.registry,
        this.provider,
        this.clusterId
      );
      
      await tss.distributeShares(privateSpendKey, addresses);
      
      // Step 8: Start refresh coordinator
      console.log('\n  üîÑ Initializing Refresh Coordinator...');
      //       this.refreshCoordinator = new RefreshCoordinator(
      //         this.wallet,
      //         this.registry,
      //         this.provider,
      //         this.staking
      //       );
      //       
      //       await this.refreshCoordinator.registerCluster(this.clusterId);
      //       await this.refreshCoordinator.startMonitoring();
      //       
      console.log('\n‚úÖ CLUSTER OPERATIONAL WITH DYNAMIC TSS!');
      console.log('üîí Your key is split into 11 encrypted shares');
      console.log('üîÑ Automatic refresh monitoring active');
      console.log('üöÄ Bridge node ready and earning rewards\n');
      
    } catch (error) {
      console.error('‚ùå Cluster finalization failed:', error.message);
      console.log('\nWill retry...');
    }
  }


  async resumeShareDistribution() {
    try {
      // Fetch private key and cluster members, then submit shares
      const privateSpendKey = await this.monero.queryKey('spend_key');
      const clusterInfo = await this.registry.getClusterInfo(this.clusterId);
      const addresses = clusterInfo[0];

      console.log('  Resuming share distribution to', addresses.length, 'members...');
      const tss = new EnhancedTSSManager(this.wallet, this.registry, this.provider, this.clusterId);
      await tss.distributeShares(privateSpendKey, addresses);
      console.log('  ‚úì Share distribution resumed');
    } catch (e) {
      if (e.message.includes('Already submitted')) {
        console.log('  ‚úì Shares already submitted for this cluster');
      } else {
        console.log('  Failed to resume share distribution:', e.message);
      }
    }
  }

}

// Start node
if (require.main === module) {
  const node = new ZNode();
  node.start().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

module.exports = ZNode;
